#Узоқ масофадаги процедурани чақириш (Remote procedure call (RPC))
##(Go RabbitMQ клиентни қўллаган ҳолда)

Иккинчи қўлланмада биз Work Queues ни вақт-қамровида қийин масалаларни бир нечта ишчига тақсимлашни ўргангандик.

Лекин, биз узоқ масофадаги компьютерда функцияни чақирсакда ва натижани кутсак нима бўлади? Бу энди умуман бошқа йўналиш. Ушбу модель узоқ масофадаги процедурани чақириш (Remote Procedure Call ёки RPC) каби таниқли.

Ушбу қўлланмада биз RabbitMQ ни RPC тизимни яратишш учун қўлламоқчимиз: клиент ва масштаблашувчи RPC сервер. Биз айни дамда ҳеч қандай мураккаб масалага дуч келмаётганимиз учун биз фибоначчи сонларини қайтарадиган ясама RPC хизматини яратмоқчимиз.

#Навбатни қайта чақириш (Callback queue)

Умуман олганда RPC ни RabbitMQ устида яратиш онсон. Клиент сўров билан ҳабар жўнатади ва сервер ҳабар билан жавоб беради. Жавобни олиш учун биз 'callback' навбат манзилини сўров билан бирга жўнатамиз. Биз одатдаги навбатни қўллашимиз мумкин. Келинг буни қилишга уриниб кўрамиз:
```
q, err := ch.QueueDeclare(
  "",    // name
  false, // durable
  false, // delete when usused
  true,  // exclusive
  false, // noWait
  nil,   // arguments
)

err = ch.Publish(
  "",          // exchange
  "rpc_queue", // routing key
  false,       // mandatory
  false,       // immediate
  amqp.Publishing{
    ContentType:   "text/plain",
    CorrelationId: corrId,
    ReplyTo:       q.Name,
    Body:          []byte(strconv.Itoa(n)),
  })
```
##Ҳабар ҳислатлари
AMQP протоколи олдиндан белгилаб қўйилган 14 та ҳислатни ҳабарга қўшиб жўната олади. Қуйидагилардан бошқа кўплари кам ишлатилади:

•	persistent(турғунлик): Ҳабарни турғун ҳолатда (true қийматда) ёки алмашинувчан (false қийматда) белгилайди. Сиз эҳтимол буни иккинчи қўлланмадан билсангиз керак.

•	content_type: mime-type кодлаштиришни аниқлайди. Масалан, кодлаш учун амалда кўп синалган JSON ишлатилади ва уни қўллаш учун application/json дан фойдаланинг.

•	reply_to: callback навбат номини кўрсатиш учун қўлланилади.

•	correlation_id: сўровларни RPC жавоблари билан мослаштириш учун фойдали ҳисобланади.

##Ўзаро боғланиш ID (Correlation Id)

Юқорида келтирилган методда биз ҳар бир RPC сўров учун callback навбатни яратамиз. Бу етарли даражада самара беради, лекин унданда яхши йўл бор – келинг ҳар бир клиент учун битта callback навбат яратамиз.

Бу янги муаммони кўтаради, жавобни қабул қилиб қайси сўровга бу жавоб тегишли эканлигини аниқлаб бўлмайди. Мана қачон correlation_id ишлатилади. Биз унга ҳар бир сўров учун такрорланмас қиймат бермоқчимиз. Кейинроқ, қачонки биз callback навбатда ҳабар қабул қилганимизда биз ушбу ҳислатга эътибор беоамиз ва унга қараб қайси жавоб қайси сўровга тегишли эканлигини аниқлаштириб оламиз. Агар биз номаълум correlation_id  қийматни кўрсак биз балки хавфсизлик билан ушбу сўровга боғлиқ бўлмаган ҳабарни бекор қилишимиз мумкин.

Сиз савол беришингиз мумкин: нимага биз уларни callback навбатда аниқланмаган ҳабар дея йўқ қилишимз керак ва нима учун етишмовчилик хатолиги деб олмаябмиз уларни? Бу сервер томонда “пойга” имконияти ҳолатига боғлиқ. Аммо эҳтимол RPC сервер жавобни бизга жўнатгандан кейин ўлар, лекин у аввал сўров учун тасдиқ ҳабарини жўнатади. Агар бу юз берса у ҳолда қайта юкланган RPC сервер сўров жараёнини қайта ишлай бошлайди. Мана нима учун клиент томонда биз дубликатоар билан ундай муносабатда бўлишимиз керак. RPC яна идеал ҳолатда идемпотент* бўлиши керак.

*идемпотент – математик объектнинг ёки амалнинг хусусиятини англатувчи термин бўлиб, амални объектга қайта қўллаш яна бир хил натижа беришидир. 

#Хулоса

![](6.1.png)

Бизнинг RPC қуйидагига ўхшаб ишлайди:

•	Клиент ишга тушган вақтда у махсус callback навбат яратади. 

•	RPC  сўрови учун клиент ҳабарни иккита хоссаси билан жўнатади: callback навбатни қийматлаб олган reply_to ва ҳар бир сўров учун такрорланмас бўлган correlation_id.

•	Сўров rpc_queue навбатга жўнатилади.

•	RPC ишчи (яъни: сервер) ушбу навбатда сўровларни кутади. Агар сўров пайдо бўлса у бажариши керак бўлган ишини бажариб ҳабарни жавоб билан биргаликда reply_to майдонида кўрсатилган навбатга жўнатади.

•	Клиент callback навбатда маълумотларни кутади. Қачон ҳабар пайдо бўлса у correlation_id ни текширади. Агар у сўровдаги қиймат билан мос келса у ҳолда программага жавоб қайтарилади.

#Барчасини биргаликда қўйсак
Фибоначчи функцияси:

```
func fib(n int) int {
        if n == 0 {
                return 0
        } else if n == 1 {
                return 1
        } else {
                return fib(n-1) + fib(n-2)
        }
}
```
Биз фибоначчи функциясини эълон қилдик. У фақат бутун сондаги қийматни қабул қилади. (Буни катта сонга ишлашини кутманг ва яна эҳтимол бу энг секин ишлайдиган рекурсив функциядир).

